# X轴生成的核心思想：

1.初始化x轴的时候以当前时间为时间范围的END,然后根据传入的时间类型例如1m为单位，以End为坐标向前推n个单位（例如5个单位）那么图表当前显示的开始时间为【当前时间 - n个单位】结束时间为【当前时间】。
2.为了达到当前时间居中在画面中的目的，再以当前时间往后推n个单位（例如五个单位）作为当前画面展示的结束时间。那么开始时间就是【当前时间 - n个单位】结束时间就是【当前时间 + n个单位】。并保存所有在推算过程中产生的x的Tick。
3.在用户操作移动的时候，实际只移动x坐标,我根据用户移动鼠标的方向和距离，根据最大宽度算出比例，然后再算到x轴的【开始时间】和【结束时间】需要向前更新到什么位置或者向后更新到什么位置。
4.在完成【开始时间】和【结束时间】的更新以后，使用更新后的【开始时间】和【结束时间】对上次产生的Tick求交集。

5.求交集的目的是，在所有上次产生的tick里找到当前【开始时间】和【结束时间】对应范围内的开始和结束Tick的下标。一开始我使用的是单次循环，但是数据量大的时候非常耗时且卡顿。后来更新成了二分查找法，且分别单独查找开始和结束Tick，之后经过一些巧思，发觉可以将二分查找改为, 查找开始时始终从0 ~ end进行遍历。查找结束点时，始终从end ~ 0进行遍历。这样一来便加快了查找的效率。

6.找到开始和结束Tick的下标之后，如果用户鼠标是往右边移动，就补全左边的Tick,并去掉右边多余的Tick。如果用户是往右边移动鼠标，就补全右边的Tick,去掉左边多余的Tick。

7.用美观算法计算显示tick: 所有产生的Tick会很多很密集，例如现在显示的是1分钟的数据，但是开始和结束时间的范围在1天左右，那么就有1440多个tick，不可能显示这么多这么密集的tick,那么就需要使用一种算法，算出合适的tick数量。算法细节大概是，比如现在Tick组中最末尾的时间是12：22那么我会先将此时间规整到12：00，然后查找11:00的，依次类推，来查找等差数列，找到Tick中不存在位置。那么刚刚那个等差数列可以被命名为“小时”等差数列。我会用这种方式找“分钟”“小时”“天”“5天”“周”“15天”的等差数列数组，然后再在这个组里找到最合适用户传入MaxDisplayTick数量的，并将其设置为【显示Tick组】

8：为了使用户友好地阅读数据点上的文字，我将这些文字做了一些格式化，寻找等差数列的时候，就自动将其格式化成了“几分”“几月份”或者“几几年”这样的文本，而且为了支持多语言，还可以切换中文或者英文。

# **y轴计算的核心思想**

1.由于y轴的渲染和计算与数据渲染和x轴渲染并不耦合，所以y轴的计算主要提供一个“updateAxisSates”函数来进行就行了，函数接收以下参数:viewWidth:number, viewHeight:number, dataScope:numberScope。也就是视窗的像素大小，以及y轴目前需要显示的最大值和最小值。

2.最开始的方案是直接在dataScope里平均找8~4个数值显示，但是缺点是这平均算出来的数值都没什么规律，全部带小数点，人第一眼看起来找不到数字的重点

3.最终还是使用等差数列的算法来算，为了兼容一些小数点很小的数字，我将y轴范围的开始和结束值，直接加权10000000（7位数）换算成整数，然后将最后一个数字四舍五入成一个整数，比如1.256就算成了12560000再将12560000转换成12600000, 然后为了让数字看起来好看，我先用10来整除开始和结束值的差，这个10就是等差数列的差数种子，用这个差数种子来探查这个数值范围内多少个tick,如果超过MaxDisplayTick数值，就将这个差数种子后面再加个0，比如100来除一直重复这个过程到数量落到MaxDisplayTick内。然后拿到这个数量，例如是8个，再进入一个循环，从四舍五入后的开始值比如12600000，往上按照之前得出的差数种子累加，直到超过结束值的范围，便取到了Y轴的Tick。

# **数据计算的核心思想**

1.数据将根据比当前设置数据时间跨度小的数据进行归并。归并逻辑是将同一时间粒度下的数据由当前开始往过去进行聚合，每一条数据都有时间，将其按照当前设置的时间格式规整，并将数据归并到当前时间桶中，时间桶中有数据的话，open的取值为时间桶中open的值，close的取值为当前数据close的值，high的取值为时间桶中high的值和当前数据high的值中的最大值，low的取值为时间桶中low的值和当前数据low的值中的最小值，volume的取值为时间桶中volume的值和当前数据volume的值的和。 循环数据并将数据融合完成得到归并好的数据集。

2.现在假设有一堆数据，我们会参照x轴的tick和y轴的开始结束值计算每一个candle柱子的大小和位置，但是如果每次拖动数据的话，都进行全量计算就太消耗性能了，我这里的做法是：第一次渲染，先通过x轴的tick循环从数据堆中找出每一个数据，然后计算每个数据的大小位置，一旦计算过的candle就打一个标记，下次有增量更新的时候，只计算增量的没有计算标记的candle,并且在增量更新时会发生缩放，这个地方是通过重新计算y轴最大值最小值，再按照之前的y轴最大值最小值，计算到一个比例，将这个缩放比例给到绘制candle的容器来实现缩放，这样一来就可以避免全量计算，每次更新图像只计算少量数据。另外还有一个优化，就是在拖拽的时候我做了一个更新防抖时间为50毫秒，并在用户拖拽图表的时候监听用户的鼠标移动速度，当移动速度小于某个值的时候才运行更新函数。
