# X轴生成的核心思想

1. 初始化时以当前时间为 END，根据时间类型（如 1m）向前推 n 个单位（如 5 个），得到范围【当前时间 − n】【当前时间】。
2. 为了让当前时间居中显示，再以当前时间向后推 n 个单位作为结束时间，范围变为【当前时间 − n】【当前时间 + n】；在推算过程中保存所有产生的 X 轴 Tick。
3. 用户拖拽移动时，实际只移动 X 坐标：根据鼠标方向与距离，按容器最大宽度换算比例，再映射为时间偏移，更新 X 轴【开始/结束时间】。
4. 完成【开始/结束时间】的更新后，使用更新后的范围与上次 Tick 求交集，快速定位可复用区间。
5. 交集查找优化：从单次循环 O(n) → 二分 O(log n) → 正反向查找（开始：0→end；结束：end→0）进一步降低平均耗时。
6. 动态补全：向右移动补全左侧 Tick 并移除右侧多余；向左移动补全右侧 Tick 并移除左侧多余。
7. 美观显示（Nice Ticks）：当 Tick 过多（如 1 分钟跨 1 天≈1440 条），先将末尾时间规整（如 12:22→12:00），按“分钟/小时/天/5 天/周/15 天”等等差序列筛选，选择与 `MaxDisplayTick` 最匹配的一组作为显示 Tick。
8. 文本与多语言：在寻找等差序列时，同时将标签格式化为“几分/几月份/几几年”等文本，并支持中英文切换。

---

# y轴计算的核心思想

1. Y 轴与数据渲染、X 轴渲染解耦，只提供 `updateAxisSates(viewWidth: number, viewHeight: number, dataScope: numberScope)` 接口；其中 `dataScope` 为当前需要显示的最小/最大值。
2. 早期方案是在 `dataScope` 内等分 4~8 个值，但刻度不“好看”，小数多、规律性差。
3. 采用等差序列（Nice Number / Nice Ticks）算法：将起止值放大 10^7 转为整数，末尾位四舍五入（如 1.256→12560000→12600000）；以 10 为差值种子探查刻度数量，若超过 `MaxDisplayTick` 则提高数量级（如 ×10→100），直到落入阈值；从“漂亮”的起点按步长累加，直至超过结束值，得到 Y 轴 Tick。

---

# 数据计算的核心思想

1. 归并（Merge）与时间桶（Time Bucket）聚合：当原始数据粒度小于当前时间粒度时，将每条数据按当前时间类型规整进时间桶，并在桶内聚合：

   - open：时间桶内最早一条的 open；
   - close：时间桶内最晚一条的 close；
   - high：时间桶内所有 high 的最大值；
   - low：时间桶内所有 low 的最小值；
   - volume：时间桶内所有 volume 的和。
     循环融合完成后得到归并好的数据集。
2. 增量计算与缩放复用（避免全量重算）：

   - 首次渲染：通过 X 轴 Tick 从数据堆中取出每个数据，计算每个 candle 的大小与位置，并给计算过的 candle 打上标记；
   - 增量更新：只计算新增/未标记的 candle；
   - 缩放：先重新计算可见数据的 Y 轴最值，再与上一次最值计算比例，将缩放比例应用于绘制容器，避免对所有 candle 重算；
   - 交互优化：拖拽时设置约 50ms 的更新防抖，并监听鼠标移动速度，仅在低速时触发更新函数，以保障流畅度。
